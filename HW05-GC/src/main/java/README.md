Если принять, что на данной машине у нас работает веб сервис, который постоянно обрабатывает запросы от пользователей,
то в данной ситуации более оптимален сборщик G1, т.к. у него наименьшая продолжительность работ (3.3 с).
Но, у G1, на мой взгляд, есть один минус - он долго работает до "out of memory" (8,12 у G1 против 4,47 у Parallel), 
что может привести к тому, что запустив сервис в продакшен, мы можем поймать ошибку в далёком горизонте. 
Исходя из этого, для бета-тестирования я бы использовал сборщик Parallel, а в релизе уже перешёл бы на G1. 

Время работы | Конфигурация                     |	Средняя нагрузка|Запуски | Запуски |	Средняя       | Средняя          | Общая
программы	 |                                  |   процессора, %   | minor	 | major   |продолжительность |продолжительность,| продолжительность,
             |                                  |                   |        |         |работы minor, мс  |         мс       |     с
2	          Xms256m -Xmx256m -XX:+UseSerialGC	        12	            14	    24	            26	                196	            5.1
1.02	      Xms256m -Xmx256m -XX:+UseParallelGC	    42	            22	    13	            26	                126	            2.2
1.58	      Xms256m -Xmx256m -XX:+UseG1GC	            14	            82	    14	            10	                92	            2.1
7.58	      Xms512m -Xmx512m -XX:+UseSerialGC	        13	            14	    30	            47	                329	            10.5
4.47	      Xms512m -Xmx512m -XX:+UseParallelGC	    12.3	        22	    19	            45	                181	            4.4
8.12	      Xms512m -Xmx512m -XX:+UseG1GC	            13	            76	    12	            18	                164	            3.3
							  
